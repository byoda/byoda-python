'''
Automatically generated code for GraphQL support for a Byoda servce

:maintainer : Steven Hessing <steven@byoda.org>
:copyright  : Copyright 2021, 2022
:license    : GPLv3
'''

# flake8: noqa=E501

from __future__ import annotations

from uuid import UUID
from datetime import datetime, date, time
from typing import List, Optional, TypeVar
import strawberry
from strawberry.schema.config import StrawberryConfig
from strawberry.types import Info

from fastapi import HTTPException

from byoda.datamodel.member import Member as MemberClassByoda
from byoda.datatypes import DataType

import logging as loggingByoda

# from byoda.datamodel.member import Member as MemberClassByoda

from byoda.requestauth.requestauth import RequestAuth as RequestAuthByoda
from byoda.requestauth.graphql_authorization import DataOperationType as DataOperationType_Byoda
from byoda.requestauth.graphql_authorization import authorize_graphql_request as authorize_graphql_request_Byoda

_LOGGER = loggingByoda.getLogger(__name__)

GenericType = TypeVar("GenericType")

@strawberry.type
class PageInfo:
    '''
    Pagination context to navigate objects with cursor-based pagination. Here
    we have a cursor of the last object and we fetch items starting from that
    one

    Read more at:
        - https://graphql.org/learn/pagination/#pagination-and-edges
        - https://relay.dev/graphql/connections.htm
    '''

    has_next_page: bool
    has_previous_page: bool
    start_cursor: Optional[str]
    end_cursor: Optional[str]

Cursor = str

async def authenticate(root, info, data_operation: DataOperationType_Byoda):
    '''
    This is middleware called by the code generated from the Jinja
    templates implementing GraphQL support
    '''

    if not info.context or not info.context['request']:
        raise HTTPException(
            status_code=403, detail='No authentication provided'
        )

    try:
        # Checks that a client cert was provided and that the cert and
        # certchain is correct
        auth = await RequestAuthByoda.authenticate_graphql_request(
            info.context['request'], {{ service_id }}
        )
        info.context['auth'] = auth
    except Exception as exc:
        raise HTTPException(
            status_code=400, detail='Authentication failed'
        )

    if not auth.is_authenticated:
        raise HTTPException(
            status_code=403, detail='No authentication provided'
        )

    try:
        # Check whether the authenticated client is authorized to request
        # the data
        return await authorize_graphql_request_Byoda(
            data_operation, {{ service_id}}, info
        )
    except Exception as exc:
        raise HTTPException(status_code=401, detail='Not authorized')

@strawberry.input
class string_query_operator_input:
    eq: Optional[str] = None
    ne: Optional[str] = None
    vin: Optional[List[str]] = None
    nin: Optional[List[str]] = None
    regex: Optional[str] = None
    glob: Optional[str] = None

@strawberry.input
class datetime_query_operator_input:
   at: Optional[datetime] = None
   nat: Optional[datetime] = None
   after: Optional[datetime] = None
   before: Optional[datetime] = None
   atafter: Optional[datetime] = None
   atbefore: Optional[datetime] = None

@strawberry.input
class number_query_operator_input:
    eq: Optional[float] = None
    ne: Optional[float] = None
    lt: Optional[float] = None
    gt: Optional[float] = None
    elt: Optional[float] = None
    egt: Optional[float] = None

@strawberry.input
class uuid_query_operator_input:
    eq: Optional[UUID] = None
    ne: Optional[UUID] = None

{% set ns = namespace(classes_seen='') %}
{% for root_class in classes.values() %}
{%   if root_class.type != DataType.ARRAY  %}

@strawberry.type
class {{ root_class.name }}:
{%     for field in root_class.fields.values() %}
    {{ field.name }}: {% if field.name in root_class.required_fields %}{{ field.python_type }}{% else %}Optional[{{field.python_type}}]{% endif %}

{%     endfor %}{# for field in root_class.fields.values() #}

@strawberry.input
class {{ root_class.name }}_input:
{%     for field in root_class.fields.values() %}
    {{field.name }}: {{ field.python_type }}
{%     endfor %}{# for field in root_class.fields.values() #}
{%   else %}{# if root_class.type != DataType.ARRAY #}

{# avoid classes referenced by multiple root classes from being included multiple times #}
{%     set class_name_deliminated = ':' + root_class.referenced_class.name + ':' %}
{%     if class_name_deliminated not in ns.classes_seen %}
@strawberry.input
class {{ root_class.referenced_class.name }}_input_filter:
{%       for field_name, field in root_class.referenced_class.fields.items() %}
{%         if field.type == DataType.STRING %}
    {{ field_name }}: Optional[string_query_operator_input] = None
{%         elif field.type == DataType.DATETIME %}
    {{ field_name }}: Optional[datetime_query_operator_input] = None
{%         elif field.type in (DataType.INTEGER, DataType.NUMBER) %}
    {{ field_name }}: Optional[number_query_operator_input] = None
{%         elif field.type == DataType.UUID %}
    {{ field_name }}: Optional[uuid_query_operator_input] = None
{%         elif field.type == DataType.ARRAY %}
    {{ field_name }}: Optional[List[str]] = None
{%         endif %}{# if field.python_type == "str" #}
{%       endfor %}{# for field_name, field in root_class.referenced_class.fields.items() #}
{%       set ns.classes_seen = ns.classes_seen + class_name_deliminated %}
{%     endif %} {#  if class_name_deliminated not in ns.classes_seen #}
{%   endif %}{# if root_class.type != DataType.ARRAY #}
{% endfor %}{# root_class in classes.values() #}

@strawberry.type
class Query:
{% for root_class in classes.values() %}
{%   if not root_class.item_id %}
    @strawberry.field
{%     if root_class.type != DataType.ARRAY %}
    async def {{ root_class.name }}(self, info: Info) -> {{ root_class.name }}:
{%     else %}{# if root_class.type != DataType.ARRAY #}
    async def {{ root_class.name }}(self, info: Info, filters: Optional[{{ root_class.referenced_class.name }}_input_filter] = None) -> List[{{ root_class.referenced_class.name }}]:
{%     endif %}{# if root_class.type != DataType.ARRAY #}
        _LOGGER.debug('Resolving {{ root_class.name }}')

        result = await authenticate(self, info, DataOperationType_Byoda.READ)
        if not result:
            raise HTTPException(status_code=400, detail='Authentication failed')

{%     if root_class.type != DataType.ARRAY %}
        info.context['data'] = await MemberClassByoda.get_data({{ service_id }}, info)
        {{ root_class.name }}_data = {{ root_class.name }}(
{%       for field in root_class.fields.values() %}
            info.context['data']['{{ field.name }}'],
{%       endfor %}{# for field in root_class.fields.values() #}
        )
        return {{ root_class.name }}_data

{%     else %}{# if root_class.type != DataType.ARRAY #}
        data = await MemberClassByoda.get_data({{ service_id }}, info, filters)
        ret_data = []
        for obj in data or []:
            info.context['data'] = obj
            {{ root_class.referenced_class.name }}_data = {{ root_class.referenced_class.name }}(
{%       for field_name, field in root_class.referenced_class.fields.items() %}
                info.context['data']['{{ field_name }}'],
{%       endfor %}{# for field_name, field in root_class.referenced_class.fields.items() #}
            )
            ret_data.append({{ root_class.referenced_class.name }}_data)

        return ret_data

{%     endif %}{# if root_class.type != DataType.ARRAY #}
{%   endif %}{#  if not root_class.item_id #}
{% endfor %}{# for root_class in classes.values() #}

@strawberry.type
class Mutation:
{% for root_class in classes.values() %}
{%   if not root_class.item_id %}
{%     if root_class.type == DataType.OBJECT %}
    @strawberry.field
    async def mutate_{{ root_class.name }}(self, info: Info,
{%       for field in root_class.fields.values() %}
            {{ field.name }}: Optional[{{ field.python_type }}] = None,
{%       endfor %}{# for field in root_class.fields.values() #}
            ) -> {{ root_class.name }}:
        _LOGGER.debug('Root query for mutate_{{ root_class.name }}')

        # TODO: Can we differentiate somehow between CREATE / UPDATE / APPEND
        result = await authenticate(self, info,  DataOperationType_Byoda.UPDATE)
        if not result:
            raise HTTPException(status_code=400, detail='Authentication failed')

        info.context['data'] = {
{%       for field in root_class.fields.values()%}
            '{{ field.name }}': {{ field.name }},
{%       endfor %}
        }
        await MemberClassByoda.mutate_data({{ service_id }}, info)
        return {{ root_class.name }}(
{%       for field in root_class.fields.values()%}
            {{ field.name }},
{%       endfor %}
        )

{%     elif root_class.type == DataType.ARRAY %}{# if root_class.type == DataType.OBJECT #}
{# APIs for array processing #}
    @strawberry.field
    async def update_{{ root_class.name }}(self, info: Info, filters: {{ root_class.referenced_class.name }}_input_filter,
{%       for field_name, field in root_class.referenced_class.fields.items()%}
        {{ field_name }}: Optional[{{ field.python_type }}] = None,
{%       endfor %}{# for field_name, field in root_class.referenced_class.fields.items() #}
        ) -> {{ root_class.referenced_class.name }}:
        _LOGGER.debug('Root query for update_{{ root_class.name }}')

        result = await authenticate(self, info, DataOperationType_Byoda.APPEND)
        if not result:
            raise HTTPException(status_code=400, detail='Authentication failed')

        info.context['data'] = {
{%       for field_name, field in root_class.referenced_class.fields.items()%}
            '{{ field_name }}': {{ field.name }},
{%       endfor %}{# for field_name, field in root_class.referenced_class.fields.items()#}
        }

        item = await MemberClassByoda.update_data({{ service_id }}, filters, info)
        if not item:
            return

        return {{ root_class.referenced_class.name }}(
{%       for field_name, field in root_class.referenced_class.fields.items() %}
            item.get('{{ field_name }}'),
{%       endfor %}{# for field_name, field in root_class.referenced_class.fields.items()#}
        )

    @strawberry.field
    async def append_{{ root_class.name }}(self, info: Info,
{%       for field_name, field in root_class.referenced_class.fields.items() %}
{%          if field_name in root_class.referenced_class.required_fields %}
            {{ field_name }}: {{ field.python_type }},
{%          endif %}
{%       endfor %}
{%       for field_name, field in root_class.referenced_class.fields.items() %}
{%          if field_name not in root_class.referenced_class.required_fields %}
            {{ field_name }}: Optional[{{ field.python_type }}] = None,
{%          endif %}
{%       endfor %}{# for field_name, field in root_class.referenced_class.fields.items()#}
            ) -> {{ root_class.referenced_class.name }}:
        _LOGGER.debug('Root query for append_{{ root_class.name }}')

        result = await authenticate(self, info, DataOperationType_Byoda.APPEND)
        if not result:
            raise HTTPException(status_code=400, detail='Authentication failed')

        info.context['data'] = {
{%       for field_name, field in root_class.referenced_class.fields.items() %}
            '{{ field_name }}': {{ field_name }},
{%       endfor %}{# for field_name, field in root_class.referenced_class.fields.items() #}
        }
        await MemberClassByoda.append_data({{ service_id }}, info)
        return {{ root_class.referenced_class.name }}(
{%       for field_name, field in root_class.referenced_class.fields.items() %}
            {{ field_name }},
{%       endfor %}{# for field_name, field in root_class.referenced_class.fields.items() #}
        )

    @strawberry.field
    async def delete_from_{{ root_class.name }}(self, info: Info, filters: Optional[{{ root_class.referenced_class.name }}_input_filter]) -> List[Optional[{{ root_class.referenced_class.name }}]]:
        _LOGGER.debug('Root mutate for delete_from_{{ root_class.name }}')

        if not await authenticate(self, info, DataOperationType_Byoda.DELETE):
            raise HTTPException(status_code=400, detail='Authentication failed')

        data = await MemberClassByoda.delete_array_data({{ service_id }}, info, filters)
        result = []
        for item in data:
            result.append(
                {{ root_class.referenced_class.name }}(
{%       for field_name, field in root_class.referenced_class.fields.items() %}
                    item.get('{{ field_name }}'),
{%       endfor %}{# for field in root_class.referenced_class.fields.values( )#}
                )
            )

        return result
{%     endif %}{# if root_class.type == DataType.OBJECT #}
{%   endif %}

{% endfor %}{# for root_class in classes.values() #}

def get_schema():
    # This is a Strawberry Schema, not byoda.Schema
    return strawberry.Schema(
        query=Query, mutation=Mutation,
        config=StrawberryConfig(auto_camel_case=False)
    )

