'''
Automatically generated code for GraphQL support for a Byoda servce

:maintainer : Steven Hessing <steven@byoda.org>
:copyright  : Copyright 2021, 2022
:license    : GPLv3
'''

# flake8: noqa=E501

from __future__ import annotations

import typing

import strawberry
from strawberry.schema.config import StrawberryConfig
from strawberry.types import Info

from fastapi import HTTPException

from byoda.datamodel.member import Member as MemberClassByoda


import logging as loggingByoda

# from byoda.datamodel.member import Member as MemberClassByoda

from byoda.requestauth import RequestAuth as RequestAuthByoda
from byoda.requestauth.graphql_authorization import DataOperationType as DataOperationType_Byoda
from byoda.requestauth.graphql_authorization import authorize_graphql_request as authorize_graphql_request_Byoda

_LOGGER = loggingByoda.getLogger(__name__)

def authenticate(root, info, data_operation: DataOperationType_Byoda):
    '''
    This is middleware called by the code generated from the Jinja
    templates implementing GraphQL support
    '''

    if not info.context or not info.context['request']:
        raise HTTPException(
            status_code=403, detail='No authentication provided'
        )

    try:
        # Checks that a client cert was provided and that the cert and
        # certchain is correct
        auth = RequestAuthByoda.authenticate_graphql_request(
            info.context['request'], {{ service_id }}
        )
        info.context['auth'] = auth
    except Exception as exc:
        raise HTTPException(
            status_code=400, detail='Authentication failed'
        )

    if not auth.is_authenticated:
        raise HTTPException(
            status_code=403, detail='No authentication provided'
        )

    try:
        # Check whether the authenticated client is authorized to request
        # the data
        return authorize_graphql_request_Byoda(
            data_operation, {{ service_id}}, info
        )
    except Exception as exc:
        raise HTTPException(status_code=401, detail='Not authorized')

{% for root_class in classes.values() %}
{%   if root_class.type != DataType.ARRAY %}
@strawberry.type
class {{ root_class.name }}:
{%     for field in root_class.fields %}
    {{field.name }}: {{ field.python_type }}
{%     endfor %}


@strawberry.input
class {{ root_class.name }}Input:
{%     for field in root_class.fields %}
    {{field.name }}: {{ field.python_type }}
{%     endfor %}

{%   endif %}
{% endfor %}

@strawberry.type
class Query:
{% for root_class in classes.values() %}
{%   if not root_class.item_id %}
    @strawberry.field
{%     if root_class.type != DataType.ARRAY %}
    def {{ root_class.name }}(self, info: Info) -> {{ root_class.name }}:
{%     else %}
    def {{ root_class.name }}(self, info: Info) -> typing.List[{{ root_class.referenced_class.name }}]:
{%     endif %}
        _LOGGER.debug('Resolving {{ root_class.name }}')

        result = authenticate(self, info, DataOperationType_Byoda.READ)
        if not result:
            raise HTTPException(status_code=400, detail='Authentication failed')

{%     if root_class.type != DataType.ARRAY %}
        info.context['data'] = MemberClassByoda.get_data({{ service_id }}, info)
        {{ root_class.name }}_data = {{ root_class.name }}(
{%       for field in root_class.fields %}
            info.context['data']['{{ field.name }}'],
{%       endfor %}
        )
        return {{ root_class.name }}_data

{%     else %}
        data = MemberClassByoda.get_data({{ service_id }}, info)
        ret_data = []
        for obj in data or []:
            info.context['data'] = obj
            {{ root_class.referenced_class.name }}_data = {{ root_class.referenced_class.name }}(
{%       for field in root_class.referenced_class.fields %}
            info.context['data']['{{ field.name }}'],
{%       endfor %}
            )
            ret_data.append({{ root_class.referenced_class.name }}_data)

        return ret_data

{%     endif %}
{%   endif %}
{% endfor %}

@strawberry.type
class Mutation:
{% for root_class in classes.values() %}
{%   if not root_class.item_id %}
{%     if root_class.type == DataType.OBJECT %}
    @strawberry.field
    def mutate_{{ root_class.name }}(self, info: Info,
{%       for field in root_class.fields %}
        {{ field.name }}: {{ field.python_type }},
{%       endfor %}
            ) -> {{ root_class.name }}:
        _LOGGER.debug('Root query for mutate{{ root_class.name }}')

        # TODO: Can we differentiate somehow between CREATE / UPDATE / APPEND
        result = authenticate(self, info,  DataOperationType_Byoda.UPDATE)
        if not result:
            raise HTTPException(status_code=400, detail='Authentication failed')

        info.context['data'] = {
{%       for field in root_class.fields %}
            '{{ field.name }}': {{ field.name }},
{%       endfor %}
        }
        MemberClassByoda.mutate_data({{ service_id }}, info)
        return {{ root_class.name }}(
{%       for field in root_class.fields %}
            {{ field.name }},
{%       endfor %}
        )

{%     elif root_class.type == DataType.ARRAY %}
{# APIs for array processing #}
    @strawberry.field
    def append_{{ root_class.name }}(self, info: Info,
{%       for field in root_class.referenced_class.fields %}
        {{ field.name }}: {{ field.python_type }},
{%       endfor %}
        ) -> {{ root_class.referenced_class.name }}:
        _LOGGER.debug('Root query for append{{ root_class.name }}')

        result = authenticate(self, info, DataOperationType_Byoda.APPEND)
        if not result:
            raise HTTPException(status_code=400, detail='Authentication failed')

        info.context['data'] = {
{%       for field in root_class.referenced_class.fields %}
            '{{ field.name }}': {{ field.name }},
{%       endfor %}
        }
        MemberClassByoda.append_data({{ service_id }}, info)
        return {{ root_class.referenced_class.name }}(
{%       for field in root_class.referenced_class.fields %}
            {{ field.name }},
{%       endfor %}
        )
{%     endif %}
{%   endif %}

{% endfor %}

def get_schema():
    # This is a graphene.Schema, not byoda.Schema
    return strawberry.Schema(
        query=Query, mutation=Mutation,
        config=StrawberryConfig(auto_camel_case=False)
    )

